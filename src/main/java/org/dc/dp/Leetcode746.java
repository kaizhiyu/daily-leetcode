package org.dc.dp;

import java.util.Arrays;

/**
 *
 * 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
 * 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
 * 请你计算并返回达到楼梯顶部的最低花费。
 *
 * 示例 1：
 * 输入：cost = [10,15,20]
 * 输出：15
 * 解释：你将从下标为 1 的台阶开始。
 * - 支付 15 ，向上爬两个台阶，到达楼梯顶部。
 * 总花费为 15 。
 *
 * 示例 2：
 * 输入：cost = [1,100,1,1,1,100,1,1,100,1]
 * 输出：6
 * 解释：你将从下标为 0 的台阶开始。
 * - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
 * - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
 * - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
 * - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
 * - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
 * - 支付 1 ，向上爬一个台阶，到达楼梯顶部。
 * 总花费为 6 。
 *
 * 提示：
 * 2 <= cost.length <= 1000
 * 0 <= cost[i] <= 999
 *
 */
public class Leetcode746 {
    /**
     *
     * 一、启发思考：寻找子问题
     * 假设数组长度 n=9。
     * 我们要解决的问题是从 0 或 1 爬到 9 的最小花费。注意楼梯顶部是 n，不是 n−1。
     * 枚举最后一步爬了几个台阶，分类讨论：
     * 如果最后一步爬了 1 个台阶，那么我们得先爬到 8，要解决的问题缩小成：从 0 或 1 爬到 8 的最小花费。
     * 如果最后一步爬了 2 个台阶，那么我们得先爬到 7，要解决的问题缩小成：从 0 或 1 爬到 7 的最小花费。
     * 由于这两种情况都会把原问题变成一个和原问题相似的、规模更小的子问题，所以可以用递归解决。
     * 注 1：从大往小思考，主要是为了方便把递归翻译成递推。从小往大思考也是可以的。
     * 注 2：动态规划有「选或不选」和「枚举选哪个」两种基本思考方式。在做题时，可根据题目要求，选择适合题目的一种来思考。本题用到的是「枚举选哪个」。
     *
     * 二、递归怎么写：状态定义与状态转移方程
     * 因为要解决的问题都是「从 0 或 1 爬到 i」，所以定义 dfs(i) 表示从 0 或 1 爬到 i 的最小花费。
     * 枚举最后一步爬了几个台阶，分类讨论：
     * 如果最后一步爬了 1 个台阶，那么我们得先爬到 i−1，要解决的问题缩小成：从 0 或 1 爬到 i−1 的最小花费。把这个最小花费加上 cost[i−1]，就得到了 dfs(i)，即 dfs(i)=dfs(i−1)+cost[i−1]。
     * 如果最后一步爬了 2 个台阶，那么我们得先爬到 i−2，要解决的问题缩小成：从 0 或 1 爬到 i−2 的最小花费。把这个最小花费加上 cost[i−2]，就得到了 dfs(i)，即 dfs(i)=dfs(i−2)+cost[i−2]。
     * 这两种情况取最小值，就得到了从 0 或 1 爬到 i 的最小花费，即 dfs(i) = min(dfs(i−1) + cost[i−1], dfs(i−2) + cost[i−2])
     * 递归边界：dfs(0)=0, dfs(1)=0。爬到 0 或 1 无需花费，因为我们一开始在 0 或 1。
     *
     * 递归入口：dfs(n)，也就是答案。
     *
     * 复杂度分析
     * 时间复杂度：O(2^n)，其中 n 为 cost 的长度。搜索树可以近似为一棵二叉树，树高为 O(n)，所以节点个数为 O(2^n)，遍历搜索树需要 O(2^n) 的时间。
     * 空间复杂度：O(n)。递归需要 O(n) 的栈空间。
     */
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        return dfs(n, cost);
    }

    private int dfs(int i, int[] cost) {
        if (i <= 1) { // 递归边界
            return 0;
        }
        int res1 = dfs(i - 1, cost) + cost[i - 1];
        int res2 = dfs(i - 2, cost) + cost[i - 2];
        return Math.min(res1, res2);
    }

    /**
     * 注意到「先爬 1 个台阶，再爬 2 个台阶」和「先爬 2 个台阶，再爬 1 个台阶」，都相当于爬 3 个台阶，都会从 dfs(i) 递归到 dfs(i−3)。
     *
     * 一叶知秋，整个递归中有大量重复递归调用（递归入参相同）。由于递归函数没有副作用，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化：
     * 如果一个状态（递归入参）是第一次遇到，那么可以在返回前，把状态及其结果记到一个 memo 数组中。
     * 如果一个状态不是第一次遇到（memo 中保存的结果不等于 memo 的初始值），那么可以直接返回 memo 中保存的结果。
     * 注意：memo 数组的初始值一定不能等于要记忆化的值！例如初始值设置为 0，并且要记忆化的 dfs(i) 也等于 0，那就没法判断 0 到底表示第一次遇到这个状态，还是表示之前遇到过了，从而导致记忆化失效。一般把初始值设置为 −1。
     *
     * 复杂度分析
     * 时间复杂度：O(n)，其中 n 为 cost 的长度。由于每个状态只会计算一次，动态规划的时间复杂度 = 状态个数 × 单个状态的计算时间。本题状态个数等于 O(n)，单个状态的计算时间为 O(1)，所以动态规划的时间复杂度为 O(n)。
     * 空间复杂度：O(n)。有多少个状态，memo 数组的大小就是多少。
     */
    public int minCostClimbingStairs2(int[] cost) {
        int n = cost.length;
        int[] memo = new int[n + 1];
        Arrays.fill(memo, -1); // -1 表示没有计算过
        return dfs(n, memo, cost);
    }

    private int dfs(int i, int[] memo, int[] cost) {
        if (i <= 1) { // 递归边界
            return 0;
        }
        if (memo[i] != -1) { // 之前计算过
            return memo[i];
        }
        int res1 = dfs(i - 1, memo, cost) + cost[i - 1];
        int res2 = dfs(i - 2, memo, cost) + cost[i - 2];
        return memo[i] = Math.min(res1, res2); // 记忆化
    }

    /**
     *
     * 1:1 翻译成递推
     * 我们可以去掉递归中的「递」，只保留「归」的部分，即自底向上计算。
     * 具体来说，f[i] 的定义和 dfs(i) 的定义是一样的，都表示从 0 或 1 爬到 i 的最小花费。
     * 相应的递推式（状态转移方程）也和 dfs 一样：
     * f[i]=min(f[i−1]+cost[i−1],f[i−2]+cost[i−2])
     * 相当于之前是用递归去计算每个状态，现在是枚举并计算每个状态。
     *
     * 初始值 f[0]=0, f[1]=0，翻译自递归边界 dfs(0)=0, dfs(1)=0。
     * 答案为 f[n]，翻译自递归入口 dfs(n)。
     *
     */
    public int minCostClimbingStairs3(int[] cost) {
        int n = cost.length;
        int[] f = new int[n + 1];
        for (int i = 2; i <= n; i++) {
            f[i] = Math.min(f[i - 1] + cost[i - 1], f[i - 2] + cost[i - 2]);
        }
        return f[n];
    }

    /**
     *
     * 空间优化
     * 观察状态转移方程，发现一旦算出 f[i]，那么 f[i−2] 及其左边的状态就永远不会用到了。
     * 这意味着每次循环，只需要知道「上一个状态」和「上上一个状态」的 f 值是多少，分别记作 f1和 f0。它俩的初始值均为 0，对应着 f[1] 和 f[0]。
     * 每次循环，计算出新的状态 newF=min(f1+cost[i−1],f0+cost[i−2])，那么对于下一轮循环来说：
     * 「上上一个状态」就是 f1，更新 f0=f1。
     * 「上一个状态」就是 newF，更新 f1=newF。最后答案为 f1，因为最后一轮循环算出的 newF 赋给了 f1。
     * 代码实现时，可以把 i 改成从 1 遍历到 n−1，这样 newF=min(f1+cost[i],f0+cost[i−1])，可以简化一点代码。
     *
     */
    public int minCostClimbingStairs4(int[] cost) {
        int f0 = 0, f1 = 0;
        for (int i = 1; i < cost.length; i++) {
            int newF = Math.min(f1 + cost[i], f0 + cost[i - 1]);
            f0 = f1;
            f1 = newF;
        }
        return f1;
    }
}
