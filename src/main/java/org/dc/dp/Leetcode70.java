package org.dc.dp;

/**
 *
 * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
 * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
 *
 * 示例 1：
 * 输入：n = 2
 * 输出：2
 * 解释：有两种方法可以爬到楼顶。
 * 1. 1 阶 + 1 阶
 * 2. 2 阶
 *
 * 示例 2：
 * 输入：n = 3
 * 输出：3
 * 解释：有三种方法可以爬到楼顶。
 * 1. 1 阶 + 1 阶 + 1 阶
 * 2. 1 阶 + 2 阶
 * 3. 2 阶 + 1 阶
 *
 */
public class Leetcode70 {
    /**
     * 递归 + 记录返回值 = 记忆化搜索
     *
     * 「从 0 爬到 i」，所以定义 dfs(i) 表示从 0 爬到 i 有多少种不同的方法
     * 分类讨论：
     * 如果最后一步爬了 1 个台阶，那么我们得先爬到 i−1，要解决的问题缩小成：从 0 爬到 i−1 有多少种不同的方法。
     * 如果最后一步爬了 2 个台阶，那么我们得先爬到 i−2，要解决的问题缩小成：从 0 爬到 i−2 有多少种不同的方法。
     * 这两种方法是互相独立的，所以根据加法原理，从 0 爬到 i 的方法数等于这两种方法数之和，即
     * dfs(i) = dfs(i−1) + dfs(i−2)
     * 递归边界：dfs(0)=1, dfs(1)=1。从 0 爬到 0 有一种方法，即原地不动。从 0 爬到 1 有一种方法，即爬 1 个台阶。
     * 递归入口：dfs(n)，也就是答案。
     *
     * 注意到「先爬 1 个台阶，再爬 2 个台阶」和「先爬 2 个台阶，再爬 1 个台阶」，都相当于爬 3 个台阶，都会从 dfs(i) 递归到 dfs(i−3)。
     * 一叶知秋，整个递归中有大量重复递归调用（递归入参相同）。由于递归函数没有副作用，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化：
     * 如果一个状态（递归入参）是第一次遇到，那么可以在返回前，把状态及其结果记到一个 memo 数组中。
     * 如果一个状态不是第一次遇到（memo 中保存的结果不等于 memo 的初始值），那么可以直接返回 memo 中保存的结果。
     * 注意：memo 数组的初始值一定不能等于要记忆化的值！例如初始值设置为 0，并且要记忆化的 dfs(i) 也等于 0，那就没法判断 0 到底表示第一次遇到这个状态，还是表示之前遇到过了，从而导致记忆化失效。
     * 一般把初始值设置为 −1。本题由于方案数均为正数，所以可以初始化成 0。
     *
     * 复杂度分析
     * 时间复杂度：O(n)。由于每个状态只会计算一次，动态规划的时间复杂度 = 状态个数 × 单个状态的计算时间。本题状态个数等于 O(n)，单个状态的计算时间为 O(1)，所以动态规划的时间复杂度为 O(n)。
     * 空间复杂度：O(n)。有多少个状态，memo 数组的大小就是多少。
     */
    int[] cache;

    public int climbStairs(int n) {
        cache = new int[n + 1];
        return dfs(n);
    }

    private int dfs(int i) {
        if (i == 1 || i == 2) {
            return i;
        }

        if (cache[i] != 0) {
            return cache[i];
        }

        cache[i] = dfs(i - 1) + dfs(i - 2);
        return cache[i];
    }

    /**
     *
     * 我们可以去掉递归中的「递」，只保留「归」的部分，即自底向上计算。
     * 具体来说，f[i] 的定义和 dfs(i) 的定义是一样的，都表示从 0 爬到 i 有多少种不同的方法。
     * 相应的递推式（状态转移方程）也和 dfs 一样：
     * f[i]=f[i−1]+f[i−2]
     * 相当于之前是用递归去计算每个状态，现在是枚举并计算每个状态。
     *
     * 初始值 f[0]=1,f[1]=1，翻译自递归边界 dfs(0)=1,dfs(1)=1。
     * 答案为 f[n]，翻译自递归入口 dfs(n)。
     */
    public int climbStairs1(int n) {
        int[] f = new int[n + 1];
        f[0] = f[1] = 1;
        for (int i = 2; i <= n; i++) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f[n];
    }

    /**
     *
     * 空间优化
     * 观察状态转移方程，发现一旦算出 f[i]，那么 f[i−2] 及其左边的状态就永远不会用到了。
     * 这意味着每次循环，只需要知道「上一个状态」和「上上一个状态」的 f 值是多少，分别记作 f1和 f0。它俩的初始值均为 1，对应着 f[1] 和 f[0]。
     * 每次循环，计算出新的状态 newF=f1+f0，那么对于下一轮循环来说：
     * 「上上一个状态」就是 f1，更新 f0=f1。
     * 「上一个状态」就是 newF，更新 f1=newF。
     * 最后答案为 f1，因为最后一轮循环算出的 newF 赋给了 f1
     *
     */
    public int climbStairs3(int n) {
        int f0 = 1;
        int f1 = 1;
        for (int i = 2; i <= n; i++) {
            int newF = f1 + f0;
            f0 = f1;
            f1 = newF;
        }
        return f1;
    }
}
