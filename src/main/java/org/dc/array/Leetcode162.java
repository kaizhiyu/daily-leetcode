package org.dc.array;

/**
 *
 * 峰值元素是指其值严格大于左右相邻值的元素。
 * 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
 * 你可以假设 nums[-1] = nums[n] = -∞ 。
 * 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
 *
 * 示例 1：
 * 输入：nums = [1,2,3,1]
 * 输出：2
 * 解释：3 是峰值元素，你的函数应该返回其索引 2。
 *
 * 示例 2：
 * 输入：nums = [1,2,1,3,5,6,4]
 * 输出：1 或 5
 * 解释：你的函数可以返回索引 1，其峰值元素为 2；
 *      或者返回索引 5， 其峰值元素为 6。
 *
 * 提示：
 * 1 <= nums.length <= 1000
 * -231 <= nums[i] <= 231 - 1
 * 对于所有有效的 i 都有 nums[i] != nums[i + 1]
 *
 */
public class Leetcode162 {
    /**
     *
     * 定理：如果 i<n−1 且 nums[i]<nums[i+1]，那么在下标 [i+1,n−1] 中一定存在至少一个峰值。
     * 证明：反证法，假设下标 [i+1,n−1] 中没有峰值。
     * 由于 i+1 不是峰值且 nums[i]<nums[i+1]，所以一定有 nums[i+1]<nums[i+2] 成立，否则 i+1 就是峰值了。注意题目保证相邻元素不同，不存在相邻元素相等的情况。
     * 由于 i+2 不是峰值且 nums[i+1]<nums[i+2]，所以一定有 nums[i+2]<nums[i+3] 成立，否则 i+2 就是峰值了。
     * 依此类推，得
     * nums[i]<nums[i+1]<nums[i+2]<⋯<nums[n−1]>nums[n]=−∞
     * 这意味着 nums[n−1] 是峰值，矛盾，所以原命题成立。
     * 同理可得，如果 i<n−1 且 nums[i]>nums[i+1]，那么在 [0,i] 中一定存在至少一个峰值。
     * 所以，通过比较 nums[i] 和 nums[i+1] 的大小关系，从而不断地缩小峰值所在位置的范围，二分找到峰值。
     *
     * ⚠注意：二分找到的是峰值，不是 nums 的最大值。
     * ⚠注意：当我们得出在某个下标区间 [L,R] 内存在峰值时，并不意味着在 [0,L−1] 和 [R+1,n−1] 中没有峰值，而是说在 [L,R] 内存在至少一个峰值。注意题目说返回任何一个峰值下标即可。
     *
     * 细节
     * 二分的范围可以是 [0,n−2]。
     * 这是因为，如果有且仅有一个峰值，且其下标是 n−1，那么一定有
     * nums[0]<nums[1]<nums[2]<⋯<nums[n−1]
     * 这意味着每次二分更新的都是 left，那么最终答案自然就是 n−1。
     * 注意本题答案是存在的，即 [0,n−1] 中一定存在峰值，这可以用上文中的反证法证明。
     *
     *
     * 红色背景表示false，即目标峰值左侧
     * 蓝色背景表示true，即目标峰值及其右侧
     * 通过比较M和M+1指向的元素大小，来判断目标峰值的位置
     *
     * reference: https://leetcode.cn/problems/find-peak-element/
     */
    public int findPeakElement(int[] nums) {
        int left = 0, right = nums.length - 2;

        while (left <= right) {
            int mid = (right - left) / 2 + left;
            if (nums[mid] > nums[mid + 1]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }

        return left;
    }
}
