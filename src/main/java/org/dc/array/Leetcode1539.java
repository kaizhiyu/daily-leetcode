package org.dc.array;

/**
 *
 * 给你一个 严格升序排列 的正整数数组 arr 和一个整数 k 。
 * 请你找到这个数组里第 k 个缺失的正整数。
 *
 * 示例 1：
 * 输入：arr = [2,3,4,7,11], k = 5
 * 输出：9
 * 解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。
 *
 * 示例 2：
 * 输入：arr = [1,2,3,4], k = 2
 * 输出：6
 * 解释：缺失的正整数包括 [5,6,7,...] 。第 2 个缺失的正整数为 6 。
 *
 *
 * 提示：
 * 1 <= arr.length <= 1000
 * 1 <= arr[i] <= 1000
 * 1 <= k <= 1000
 * 对于所有 1 <= i < j <= arr.length 的 i 和 j 满足 arr[i] < arr[j]
 *
 */
public class Leetcode1539 {
    /**
     *
     * 按照迭代的思路，我们每遍历到数组的一个元素，就能知道在这个元素之前有多少个缺失元素，计算方式如下：
     *
     * 设：arr = [2,3,4,5,7,11], k = 5
     *
     * 我们可以利用数组下标来得到该位置之前缺失的元素数量，例如：
     *
     * i = 0，此时数组元素arr[i] = 2，在0位置上，不缺失的情况下，对应的元素应该是1，所以缺失个数为arr[i] - i - 1 = 1,
     * 因为数组下标是从0开始的，而元素是从1开始的，所以计算个数的时候，除了减掉下标值之外，还需要再减1.
     *
     * 按照这个方式，能计算出该数组的每个元素对应的缺失元素个数：
     * 我们要求的是找到缺失的第k个整数，观察每个元素对应的缺失个数，它们所构成的序列是一个非严格递增的序列，也就是说，在这个序列中，我们能够通过二分查找，找到k所对应的位置，有了这个位置，我们就能通过对应的元素找到缺失的第k个整数。
     *
     * 举例来说，如果要找到k = 5，第5个缺失的元素，那么我们需要从一个确定的数向后或向前推算：
     *
     * 对于2,3,4来说，它们之前缺少1个元素，所以我们不考虑这些元素。
     * 对于7来说，它之前缺少3个元素，那么从它开始往后推2个元素，就有可能是缺失的第5个元素。前提是它后面的元素缺失数量要大于k = 5
     * 对于11来说，它之前缺少6个元素，我们要找的第5个元素，一定是在它之前缺失的，那从它开始往前推2个元素（第6个，第5个），就是我们要找的缺失的第5个元素。
     * 根据这种分析，我们就可以在这个缺失数量的序列上进行二分查找，确定一个区间[i,j]，满足lack[i] < k <= lack[j]，
     * 则第k个缺失的数为k - (arr[i] - i - 1) + arr[i]，
     * arr[i] - i - 1表示arr[i]位置缺少的元素个数，k - 缺失个数表示从arr[i]开始还缺少几个元素，再加上arr[i]，就是第k个缺失的元素。
     *
     * 参考：https://leetcode.cn/problems/kth-missing-positive-number/solutions/1448395/-by-max-lfsznscofe-0qh4/
     */
    public int findKthPositive(int[] arr, int k) {
        if (arr[0] > k) {
            return k;
        }

        int left = 0, right = arr.length - 1;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            int x = arr[mid];
            if (x - mid - 1 >= k) {
                right = mid - 1;
            }  else {
                left = mid + 1;
            }
        }

        return k - (arr[left - 1] - (left - 1) -1) + arr[left - 1];
    }
}

